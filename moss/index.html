<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Life in the Boundary Layer — Sonified</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111824; --panel2:#0f1520; --text:#d9e3f0; --muted:#8aa0b8;
      --accent:#7dd3fc; --accent2:#a78bfa; --warn:#fbbf24; --danger:#fb7185;
      --line:#203046;
    }
    html,body{height:100%;}
    body{
      margin:0; background: radial-gradient(1200px 700px at 20% 10%, rgba(125,211,252,.12), transparent 60%),
                         radial-gradient(900px 600px at 80% 30%, rgba(167,139,250,.10), transparent 60%),
                         linear-gradient(180deg, #070a0f, #0b0f14 30%, #070a0f);
      color:var(--text); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{max-width:1100px; margin:0 auto; padding:18px 16px 28px;}
    header{
      display:flex; gap:14px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap;
      border:1px solid var(--line); background:linear-gradient(180deg, rgba(17,24,36,.92), rgba(15,21,32,.92));
      border-radius:14px; padding:14px 14px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    header h1{margin:0; font-size:18px; letter-spacing:.2px;}
    header p{margin:6px 0 0; color:var(--muted); max-width:70ch;}
    .btnrow{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    button{
      appearance:none; border:1px solid var(--line); background:#0b1220; color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:650;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    button:hover{border-color:#2c4668;}
    button.primary{background:linear-gradient(180deg, rgba(125,211,252,.22), rgba(125,211,252,.10)); border-color: rgba(125,211,252,.35);}
    button.danger{background:linear-gradient(180deg, rgba(251,113,133,.20), rgba(251,113,133,.08)); border-color: rgba(251,113,133,.35);}
    .pill{
      border:1px solid var(--line); border-radius:999px; padding:7px 10px; color:var(--muted);
      background:rgba(0,0,0,.14);
      display:flex; gap:8px; align-items:center;
    }
    .pill b{color:var(--text); font-weight:700;}
    main{display:grid; grid-template-columns: 1.15fr .85fr; gap:14px; margin-top:14px;}
    @media (max-width: 920px){ main{grid-template-columns: 1fr; } }
    .card{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(17,24,36,.90), rgba(15,21,32,.86));
      border-radius:14px; padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h2{margin:0 0 10px; font-size:14px; letter-spacing:.14px; color:#cfe2f7;}
    .grid{
      display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px;
    }
    @media (max-width: 520px){ .grid{grid-template-columns:1fr;} }
    .ctrl{
      border:1px solid rgba(32,48,70,.9); border-radius:12px; padding:10px; background:rgba(0,0,0,.14);
    }
    .ctrl label{display:flex; justify-content:space-between; gap:10px; color:var(--muted); font-size:12px;}
    .ctrl .val{color:var(--text); font-variant-numeric: tabular-nums; white-space:nowrap;}
    input[type="range"]{width:100%;}
    .small{font-size:12px; color:var(--muted);}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .scene{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;
    }
    .scene button{padding:9px 10px; font-weight:650;}
    .scene button.sel{border-color: rgba(167,139,250,.55); background:linear-gradient(180deg, rgba(167,139,250,.18), rgba(167,139,250,.07));}
    canvas{
      width:100%; height:210px; border-radius:12px; border:1px solid rgba(32,48,70,.9);
      background: linear-gradient(180deg, rgba(8,12,18,.9), rgba(10,14,22,.75));
    }
    .legend{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; color:var(--muted); font-size:12px;}
    .tag{display:flex; gap:7px; align-items:center;}
    .dot{width:10px; height:10px; border-radius:50%;}
    .dot.wind{background:rgba(125,211,252,.9);}
    .dot.heat{background:rgba(251,191,36,.9);}
    .dot.humid{background:rgba(52,211,153,.9);}
    .dot.co2{background:rgba(167,139,250,.95);}
    .dot.spores{background:rgba(251,113,133,.9);}
    details{margin-top:10px;}
    details summary{cursor:pointer; color:#cfe2f7;}
    code{color:#cfe2f7;}
    a{color:var(--accent);}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Life in the Boundary Layer — Sonified</h1>
      <p>
        A boundary layer is a thin shelter of slowed air hugging surfaces. This webapp turns that microclimate into sound:
        still air as soft vowels, turbulence as breathy noise, warmth as brightening harmonics, humidity as widening reverb,
        CO₂ as a deep “greenhouse” drone, and spore release as upward “kite” streaks.
      </p>
      <div class="row" style="margin-top:10px;">
        <span class="pill">Status: <b id="status">stopped</b></span>
        <span class="pill">Scene: <b id="sceneName">Forest Log</b></span>
        <span class="pill">Depth: <b id="depthRead">0.58</b></span>
        <span class="pill">CPU-safe: <b id="safe">on</b></span>
      </div>
    </div>
    <div class="btnrow">
      <button class="primary" id="startBtn">Start</button>
      <button class="danger" id="stopBtn" disabled>Stop</button>
      <span class="pill">Master <b id="masterDb">-18.0 dB</b></span>
    </div>
  </header>

  <main>
    <section class="card">
      <h2>Soundfield (boundary layer vs turbulent air)</h2>
      <canvas id="viz" width="980" height="420"></canvas>
      <div class="legend">
        <span class="tag"><span class="dot wind"></span>wind (turbulence)</span>
        <span class="tag"><span class="dot heat"></span>heat</span>
        <span class="tag"><span class="dot humid"></span>humidity</span>
        <span class="tag"><span class="dot co2"></span>CO₂ richness</span>
        <span class="tag"><span class="dot spores"></span>spore “kite” bursts</span>
      </div>

      <div class="scene">
        <button class="sel" data-scene="forest">Forest Log</button>
        <button data-scene="rock">Sunlit Rock</button>
        <button data-scene="desert">Desert Dew</button>
        <button data-scene="pasture">Kite Wind</button>
      </div>

      <details>
        <summary>Mapping notes (based on the chapter)</summary>
        <div class="small" style="margin-top:8px;">
          <ul>
            <li><b>Boundary layer depth</b> sets how “protected” the sound is: deeper = warmer, wetter, more CO₂, slower wind.</li>
            <li><b>Still air</b> is voiced as steady vowels (FM “vocal” formants) close to the surface.</li>
            <li><b>Turbulent zone</b> is breath/noise with faster modulation and more stereo motion.</li>
            <li><b>Heat trap</b> brightens upper partials and opens a gentle high shelf.</li>
            <li><b>Humidity trap</b> increases reverb width/decay and adds a faint chorus-like detune.</li>
            <li><b>CO₂ enrichment</b> adds a low, steady drone that feeds the “photosynthesis” vowels.</li>
            <li><b>Spores on setae</b> become occasional rising streaks that jump above the boundary layer.</li>
          </ul>
        </div>
      </details>
    </section>

    <aside class="card">
      <h2>Controls</h2>
      <div class="grid">
        <div class="ctrl">
          <label>Boundary layer depth <span class="val" id="depthVal">0.58</span></label>
          <input id="depth" type="range" min="0" max="1" step="0.001" value="0.58" />
          <div class="small">Deep = sheltered forest floor; shallow = exposed rock face.</div>
        </div>

        <div class="ctrl">
          <label>Wind (aloft) <span class="val" id="windVal">0.44</span></label>
          <input id="wind" type="range" min="0" max="1" step="0.001" value="0.44" />
          <div class="small">Controls turbulence/noise above the layer.</div>
        </div>

        <div class="ctrl">
          <label>Heat (sun trap) <span class="val" id="heatVal">0.52</span></label>
          <input id="heat" type="range" min="0" max="1" step="0.001" value="0.52" />
          <div class="small">Warmer boundary layer = brighter, more “alive.”</div>
        </div>

        <div class="ctrl">
          <label>Humidity <span class="val" id="humVal">0.62</span></label>
          <input id="hum" type="range" min="0" max="1" step="0.001" value="0.62" />
          <div class="small">More humidity = longer/wider reverb and slower drying.</div>
        </div>

        <div class="ctrl">
          <label>CO₂ richness <span class="val" id="co2Val">0.55</span></label>
          <input id="co2" type="range" min="0" max="1" step="0.001" value="0.55" />
          <div class="small">Adds a low drone and “feeds” vowel intensity.</div>
        </div>

        <div class="ctrl">
          <label>Spore dispersal <span class="val" id="sporeVal">0.26</span></label>
          <input id="spore" type="range" min="0" max="1" step="0.001" value="0.26" />
          <div class="small">Higher = more frequent upward “kite” streaks.</div>
        </div>

        <div class="ctrl">
          <label>FM voice: vowel shift <span class="val" id="vowelVal">0.35</span></label>
          <input id="vowel" type="range" min="0" max="1" step="0.001" value="0.35" />
          <div class="small">Morphs “oo → ah → ee” formant region.</div>
        </div>

        <div class="ctrl">
          <label>Stereo motion <span class="val" id="panVal">0.45</span></label>
          <input id="pan" type="range" min="0" max="1" step="0.001" value="0.45" />
          <div class="small">Boundary layer is steady; turbulence wanders.</div>
        </div>

        <div class="ctrl">
          <label>Reverb amount <span class="val" id="revVal">0.58</span></label>
          <input id="reverb" type="range" min="0" max="1" step="0.001" value="0.58" />
          <div class="small">Stereo reverb (generated impulse; no files).</div>
        </div>

        <div class="ctrl">
          <label>Master level <span class="val" id="masterVal">0.20</span></label>
          <input id="master" type="range" min="0" max="1" step="0.001" value="0.20" />
          <div class="small">Start low; FM + reverb can peak.</div>
        </div>
      </div>

      <details>
        <summary>Tip (headphones recommended)</summary>
        <div class="small" style="margin-top:8px;">
          Use headphones to hear the <b>still boundary layer</b> as centered vowels and the <b>turbulent zone</b> as wide, panned breath.
          Try <b>Sunlit Rock</b> and raise <b>heat</b>, then switch to <b>Forest Log</b> and raise <b>humidity</b>.
        </div>
      </details>
    </aside>
  </main>
</div>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (x, a=0, b=1) => Math.min(b, Math.max(a, x));
  const lerp = (a,b,t) => a + (b-a)*t;
  const smoothstep = (a,b,x) => {
    const t = clamp((x-a)/(b-a));
    return t*t*(3-2*t);
  };
  const dbToGain = (db) => Math.pow(10, db/20);
  const gainToDb = (g) => 20 * Math.log10(Math.max(1e-8, g));
  const now = (ctx) => ctx.currentTime;

  function setParam(param, value, t, tau=0.03){
    // dezipper
    param.cancelScheduledValues(t);
    param.setTargetAtTime(value, t, tau);
  }

  // ---------- UI ----------
  const $ = (id) => document.getElementById(id);
  const ui = {
    startBtn: $("startBtn"),
    stopBtn: $("stopBtn"),
    status: $("status"),
    sceneName: $("sceneName"),
    depthRead: $("depthRead"),
    safe: $("safe"),
    masterDb: $("masterDb"),
    canvas: $("viz"),

    depth: $("depth"), wind: $("wind"), heat: $("heat"), hum: $("hum"), co2: $("co2"), spore: $("spore"),
    vowel: $("vowel"), pan: $("pan"), reverb: $("reverb"), master: $("master"),

    depthVal: $("depthVal"), windVal: $("windVal"), heatVal: $("heatVal"), humVal: $("humVal"),
    co2Val: $("co2Val"), sporeVal: $("sporeVal"), vowelVal: $("vowelVal"), panVal: $("panVal"),
    revVal: $("revVal"), masterVal: $("masterVal"),
  };

  const sceneButtons = Array.from(document.querySelectorAll(".scene button[data-scene]"));

  function fmt(x){ return (+x).toFixed(2); }
  function bindRange(el, outEl, cb){
    const upd = () => { outEl.textContent = fmt(el.value); cb?.(+el.value); };
    el.addEventListener("input", upd);
    upd();
  }

  // ---------- Audio Engine ----------
  let ctx = null;
  let raf = null;

  // Nodes
  let masterGain, masterLimiter, analyser;
  let dryGain, wetGain, convolver, revPreDelay;
  let voiceBus, airBus, sporeBus, co2Bus;
  let stereoWidth; // mid/side style
  let eqLow, eqHigh;

  // Voice synth (FM + formants)
  let vCarrier, vMod, vModGain, vAmp;
  let vForm1, vForm2, vForm3; // bandpasses in parallel
  let vFormMix;

  // Air (noise turbulence)
  let nSrc, nAmp, nHP, nBP, nPan;

  // CO2 drone
  let cOsc, cAmp, cLP, cPan;

  // Spores (burst FM streaks)
  const spores = []; // active voices

  // Modulators
  let lfoPan, lfoPanGain, lfoBreath, lfoBreathGain;
  let lfoWarm, lfoWarmGain;

  // State
  const state = {
    scene: "forest",
    depth: 0.58,
    wind: 0.44,
    heat: 0.52,
    hum: 0.62,
    co2: 0.55,
    spore: 0.26,
    vowel: 0.35,
    pan: 0.45,
    reverb: 0.58,
    master: 0.20,
    running: false,
    cpuSafe: true
  };

  const SCENES = {
    forest:  { name:"Forest Log",  depth:0.70, wind:0.28, heat:0.42, hum:0.78, co2:0.68, spore:0.22, vowel:0.30, pan:0.40, reverb:0.66 },
    rock:    { name:"Sunlit Rock", depth:0.30, wind:0.62, heat:0.80, hum:0.35, co2:0.32, spore:0.16, vowel:0.52, pan:0.55, reverb:0.30 },
    desert:  { name:"Desert Dew",  depth:0.22, wind:0.50, heat:0.55, hum:0.22, co2:0.24, spore:0.10, vowel:0.18, pan:0.60, reverb:0.18 },
    pasture: { name:"Kite Wind",   depth:0.45, wind:0.78, heat:0.50, hum:0.45, co2:0.40, spore:0.45, vowel:0.44, pan:0.70, reverb:0.40 }
  };

  function makeNoiseBuffer(ctx, seconds=2){
    const sr = ctx.sampleRate;
    const len = Math.floor(seconds * sr);
    const buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    let x1=0, x2=0, x3=0;
    for(let i=0;i<len;i++){
      // slightly "airy" pink-ish noise (filtered)
      const white = (Math.random()*2-1);
      x1 = 0.997*x1 + 0.029591*white;
      x2 = 0.985*x2 + 0.032534*white;
      x3 = 0.950*x3 + 0.048056*white;
      d[i] = (x1 + x2 + x3) * 0.33;
    }
    return buf;
  }

  function makeStereoImpulse(ctx, seconds=2.6, decay=3.2, width=0.6){
    // Two-channel generated impulse response with slight L/R decorrelation.
    const sr = ctx.sampleRate;
    const len = Math.max(1, Math.floor(seconds * sr));
    const ir = ctx.createBuffer(2, len, sr);
    const L = ir.getChannelData(0);
    const R = ir.getChannelData(1);

    // simple seeded RNG for consistent decorrelation per build
    let seed = 1337;
    const rnd = () => (seed = (seed*16807)%2147483647) / 2147483647;

    for(let i=0;i<len;i++){
      const t = i / sr;
      const env = Math.pow(1 - i/len, decay);
      // a touch of early reflections + diffuse tail
      const early = (i < sr*0.03) ? 1.0 : 0.0;
      const burst = early ? (rnd()*2-1) * 0.9 : 0.0;

      // decorrelated noise
      const n1 = (rnd()*2-1);
      const n2 = (rnd()*2-1);

      // slight "flutter" to avoid metallic ringing
      const flutter = 0.5 + 0.5*Math.sin(2*Math.PI*(6.5*t + 0.07*Math.sin(2*Math.PI*0.9*t)));

      // width controls difference between channels
      const mid = (n1 + n2) * 0.5;
      const side = (n1 - n2) * 0.5;

      const left = (mid + side*width) * env * flutter + burst;
      const right= (mid - side*width) * env * flutter + burst;

      L[i] = left * 0.45;
      R[i] = right * 0.45;
    }
    return ir;
  }

  function buildAudio(){
    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });

    // Master chain
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.0;

    // A soft limiter with dynamics compressor
    masterLimiter = ctx.createDynamicsCompressor();
    masterLimiter.threshold.value = -14;
    masterLimiter.knee.value = 18;
    masterLimiter.ratio.value = 10;
    masterLimiter.attack.value = 0.004;
    masterLimiter.release.value = 0.12;

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;

    // Dry/Wet
    dryGain = ctx.createGain();
    wetGain = ctx.createGain();
    dryGain.gain.value = 0.9;
    wetGain.gain.value = 0.35;

    // "Stereo reverb": pre-delay then convolver with stereo IR
    revPreDelay = ctx.createDelay(0.12);
    revPreDelay.delayTime.value = 0.024;

    convolver = ctx.createConvolver();
    convolver.normalize = true;
    convolver.buffer = makeStereoImpulse(ctx, 2.8, 3.2, 0.75);

    // EQ sweetening
    eqLow = ctx.createBiquadFilter();
    eqLow.type = "lowshelf";
    eqLow.frequency.value = 160;
    eqLow.gain.value = 1.0;

    eqHigh = ctx.createBiquadFilter();
    eqHigh.type = "highshelf";
    eqHigh.frequency.value = 3200;
    eqHigh.gain.value = 0.0;

    // Buses
    voiceBus = ctx.createGain();
    airBus   = ctx.createGain();
    sporeBus = ctx.createGain();
    co2Bus   = ctx.createGain();
    voiceBus.gain.value = 0.9;
    airBus.gain.value   = 0.8;
    sporeBus.gain.value = 0.75;
    co2Bus.gain.value   = 0.6;

    // Width: mid/side-ish using ChannelSplitter/Merger
    // We'll fake "width" by feeding wet signal through a short decorrelation delay + opposite polarity.
    // (Simpler than full M/S; good enough and dependency-free.)
    stereoWidth = {
      splitter: ctx.createChannelSplitter(2),
      merger: ctx.createChannelMerger(2),
      dl: ctx.createDelay(0.03),
      dr: ctx.createDelay(0.03),
      gl: ctx.createGain(),
      gr: ctx.createGain()
    };
    stereoWidth.dl.delayTime.value = 0.012;
    stereoWidth.dr.delayTime.value = 0.017;
    stereoWidth.gl.gain.value = 0.25;
    stereoWidth.gr.gain.value = -0.25;

    // Routing: sources -> dry + wet -> master -> analyser -> destination
    const sum = ctx.createGain();
    voiceBus.connect(sum);
    airBus.connect(sum);
    sporeBus.connect(sum);
    co2Bus.connect(sum);

    sum.connect(dryGain);
    sum.connect(revPreDelay);

    revPreDelay.connect(convolver);
    convolver.connect(stereoWidth.splitter);

    stereoWidth.splitter.connect(stereoWidth.dl, 0);
    stereoWidth.splitter.connect(stereoWidth.dr, 1);
    stereoWidth.dl.connect(stereoWidth.gl);
    stereoWidth.dr.connect(stereoWidth.gr);
    // Merge: original wet + side component
    convolver.connect(stereoWidth.merger);
    stereoWidth.gl.connect(stereoWidth.merger, 0, 0);
    stereoWidth.gr.connect(stereoWidth.merger, 0, 1);

    stereoWidth.merger.connect(wetGain);

    // Mix dry/wet
    const mix = ctx.createGain();
    dryGain.connect(mix);
    wetGain.connect(mix);

    mix.connect(eqLow);
    eqLow.connect(eqHigh);
    eqHigh.connect(masterLimiter);
    masterLimiter.connect(masterGain);
    masterGain.connect(analyser);
    analyser.connect(ctx.destination);

    // ---------- Voice FM "vocal" ----------
    vCarrier = ctx.createOscillator();
    vCarrier.type = "sine";
    vMod = ctx.createOscillator();
    vMod.type = "sine";
    vModGain = ctx.createGain();
    vAmp = ctx.createGain();
    vAmp.gain.value = 0.0;

    // FM: mod -> modGain -> carrier.frequency
    vMod.connect(vModGain);
    vModGain.connect(vCarrier.frequency);

    // Formant filters
    vForm1 = ctx.createBiquadFilter(); vForm1.type = "bandpass"; vForm1.Q.value = 9.0;
    vForm2 = ctx.createBiquadFilter(); vForm2.type = "bandpass"; vForm2.Q.value = 10.0;
    vForm3 = ctx.createBiquadFilter(); vForm3.type = "bandpass"; vForm3.Q.value = 12.0;

    vFormMix = ctx.createGain();
    vFormMix.gain.value = 0.85;

    // carrier -> amp -> split to formants -> mix -> voiceBus
    vCarrier.connect(vAmp);
    vAmp.connect(vForm1);
    vAmp.connect(vForm2);
    vAmp.connect(vForm3);
    vForm1.connect(vFormMix);
    vForm2.connect(vFormMix);
    vForm3.connect(vFormMix);

    // subtle saturation via waveshaper (gentle)
    const shaper = ctx.createWaveShaper();
    shaper.curve = (() => {
      const n = 1024;
      const c = new Float32Array(n);
      for(let i=0;i<n;i++){
        const x = (i/(n-1))*2-1;
        c[i] = Math.tanh(1.6*x);
      }
      return c;
    })();
    shaper.oversample = "2x";

    vFormMix.connect(shaper);
    shaper.connect(voiceBus);

    // ---------- Turbulent air noise ----------
    const noiseBuf = makeNoiseBuffer(ctx, 2.0);
    nSrc = ctx.createBufferSource();
    nSrc.buffer = noiseBuf;
    nSrc.loop = true;

    nHP = ctx.createBiquadFilter();
    nHP.type = "highpass"; nHP.frequency.value = 280;

    nBP = ctx.createBiquadFilter();
    nBP.type = "bandpass"; nBP.frequency.value = 1200; nBP.Q.value = 0.7;

    nAmp = ctx.createGain();
    nAmp.gain.value = 0.0;

    nPan = ctx.createStereoPanner();
    nPan.pan.value = 0.0;

    nSrc.connect(nHP);
    nHP.connect(nBP);
    nBP.connect(nAmp);
    nAmp.connect(nPan);
    nPan.connect(airBus);

    // ---------- CO2 drone ----------
    cOsc = ctx.createOscillator();
    cOsc.type = "triangle";
    cLP = ctx.createBiquadFilter();
    cLP.type = "lowpass"; cLP.frequency.value = 180; cLP.Q.value = 0.7;

    cAmp = ctx.createGain(); cAmp.gain.value = 0.0;

    cPan = ctx.createStereoPanner();
    cPan.pan.value = 0.0;

    cOsc.connect(cLP);
    cLP.connect(cAmp);
    cAmp.connect(cPan);
    cPan.connect(co2Bus);

    // ---------- LFOs ----------
    lfoPan = ctx.createOscillator();
    lfoPan.type = "sine"; lfoPan.frequency.value = 0.09;
    lfoPanGain = ctx.createGain(); lfoPanGain.gain.value = 0.0;
    lfoPan.connect(lfoPanGain);
    lfoPanGain.connect(nPan.pan);

    lfoBreath = ctx.createOscillator();
    lfoBreath.type = "sine"; lfoBreath.frequency.value = 0.13;
    lfoBreathGain = ctx.createGain(); lfoBreathGain.gain.value = 0.0;
    lfoBreath.connect(lfoBreathGain);
    // will be applied manually to various params by polling, to keep it simple and stable

    lfoWarm = ctx.createOscillator();
    lfoWarm.type = "sine"; lfoWarm.frequency.value = 0.035;
    lfoWarmGain = ctx.createGain(); lfoWarmGain.gain.value = 0.0;
    lfoWarm.connect(lfoWarmGain);
    // also polled

    // Start oscillators/sources
    vCarrier.start();
    vMod.start();
    nSrc.start();
    cOsc.start();
    lfoPan.start();
    lfoBreath.start();
    lfoWarm.start();

    // Set initial parameters
    applyAllParams(true);

    // fade in
    const t0 = now(ctx);
    setParam(masterGain.gain, state.master, t0, 0.06);
    state.running = true;
  }

  function stopAudio(){
    if(!ctx) return;
    const t0 = now(ctx);
    try{
      setParam(masterGain.gain, 0.0, t0, 0.03);
      setTimeout(async () => {
        try{ await ctx.close(); }catch(e){}
        ctx = null;
      }, 140);
    }catch(e){
      try{ ctx.close(); }catch(_){}
      ctx = null;
    }
    state.running = false;
  }

  // ---------- Parameter Mapping ----------
  function vowelFormants(vowel){
    // Morph between OO (u), AH (a), EE (i) in rough formant regions.
    // We'll blend three sets; vowel in [0,1]:
    // 0..0.5 = OO -> AH, 0.5..1 = AH -> EE
    const oo = { f1: 350, f2: 900,  f3: 2400 };
    const ah = { f1: 700, f2: 1200, f3: 2600 };
    const ee = { f1: 300, f2: 2300, f3: 3000 };

    if(vowel < 0.5){
      const t = vowel/0.5;
      return {
        f1: lerp(oo.f1, ah.f1, t),
        f2: lerp(oo.f2, ah.f2, t),
        f3: lerp(oo.f3, ah.f3, t),
      };
    }else{
      const t = (vowel-0.5)/0.5;
      return {
        f1: lerp(ah.f1, ee.f1, t),
        f2: lerp(ah.f2, ee.f2, t),
        f3: lerp(ah.f3, ee.f3, t),
      };
    }
  }

  function applyAllParams(force=false){
    if(!ctx) return;
    const t = now(ctx);

    const depth = state.depth;
    const wind  = state.wind;
    const heat  = state.heat;
    const hum   = state.hum;
    const co2   = state.co2;
    const spore = state.spore;
    const vowel = state.vowel;
    const pan   = state.pan;
    const rev   = state.reverb;

    // Boundary layer logic:
    // deeper => less wind at surface => more stable vowel, more humidity/heat retention
    const sheltered = depth; // 0..1
    const turbulent = clamp(wind * (1 - 0.65*sheltered)); // wind felt after boundary shelter

    // Voice fundamental: "moss choir" small + slow
    const baseF0 = lerp(90, 140, heat*0.65 + sheltered*0.25); // warm -> higher
    const drift = lerp(0.3, 1.2, (1-sheltered)*turbulent); // more wind -> more drift
    const modRate = lerp(1.2, 5.0, 0.25 + 0.75*turbulent);

    // FM index: humidity & CO2 feed a richer timbre; heat opens brightness
    const fmIndex = lerp(15, 90, clamp(0.15 + 0.45*co2 + 0.25*hum + 0.25*heat));
    const modFreq = baseF0 * lerp(1.5, 3.2, 0.35 + 0.65*vowel); // vowel shift affects spectral tilt

    // Voice amplitude: growth window extends with humidity; but if very windy and shallow, voice dries out
    const growth = clamp(0.15 + 0.65*hum + 0.35*sheltered - 0.40*turbulent);
    const voiceAmp = 0.06 + 0.22*growth;

    // Formants
    const F = vowelFormants(vowel);
    // Heat slightly lifts formants
    const heatLift = 1 + 0.10*heat;

    setParam(vCarrier.frequency, baseF0, t, force?0.02:0.05);
    setParam(vMod.frequency, modFreq, t, force?0.02:0.05);
    setParam(vModGain.gain, fmIndex, t, force?0.02:0.05);
    setParam(vAmp.gain, voiceAmp, t, force?0.02:0.07);

    setParam(vForm1.frequency, F.f1*heatLift, t, 0.06);
    setParam(vForm2.frequency, F.f2*heatLift, t, 0.06);
    setParam(vForm3.frequency, F.f3*heatLift, t, 0.06);

    // Air noise: turbulence is "aloft" => more amplitude and higher center frequency
    const airAmp = 0.02 + 0.22 * turbulent;
    setParam(nAmp.gain, airAmp, t, 0.06);
    setParam(nBP.frequency, lerp(650, 2400, turbulent*0.85 + heat*0.15), t, 0.06);
    setParam(nBP.Q, lerp(0.5, 1.6, 1-turbulent), t, 0.06);
    setParam(nHP.frequency, lerp(180, 520, turbulent), t, 0.06);

    // Stereo motion: more in turbulence, less in boundary layer
    lfoPan.frequency.setValueAtTime(lerp(0.03, 0.20, pan * (0.4 + 0.6*turbulent)), t);
    setParam(lfoPanGain.gain, lerp(0.05, 0.85, pan * (0.25 + 0.75*turbulent)), t, 0.08);

    // CO2 drone: deeper boundary + decomposition => more CO2, steadier, more centered
    const co2Amp = 0.01 + 0.14 * clamp(co2 * (0.35 + 0.65*sheltered));
    setParam(cAmp.gain, co2Amp, t, 0.08);
    setParam(cOsc.frequency, lerp(38, 68, 0.35*heat + 0.25*co2), t, 0.09);
    setParam(cLP.frequency, lerp(120, 280, 0.35 + 0.65*hum), t, 0.09);
    // CO2 pan: gently opposite of air motion
    setParam(cPan.pan, lerp(0.0, -0.35, pan*(0.3+0.7*turbulent)), t, 0.10);

    // Reverb: humidity widens/lengthens, wind reduces tail clarity
    const wet = clamp(0.02 + 0.80 * rev * (0.25 + 0.75*hum) * (1 - 0.35*turbulent));
    setParam(wetGain.gain, wet, t, 0.08);
    setParam(dryGain.gain, clamp(0.95 - 0.55*wet), t, 0.08);

    // Pre-delay increases a bit with "open air" (shallower boundary = clearer reflections)
    setParam(revPreDelay.delayTime, lerp(0.018, 0.060, (1-sheltered)*0.8 + turbulent*0.2), t, 0.09);

    // Width amount (side gain): higher with humidity (diffuse) and turbulence (decorrelation)
    const widthAmt = clamp(0.08 + 0.35*hum + 0.20*turbulent);
    setParam(stereoWidth.gl.gain,  widthAmt, t, 0.10);
    setParam(stereoWidth.gr.gain, -widthAmt, t, 0.10);

    // Heat as brightness (high shelf), plus slight low shelf warmth if deep
    setParam(eqHigh.gain, lerp(-1.0, 6.0, heat*(0.4+0.6*sheltered)), t, 0.12);
    setParam(eqLow.gain, lerp(0.0, 3.0, sheltered*0.8 + hum*0.2), t, 0.12);

    // Master
    setParam(masterGain.gain, state.master, t, 0.06);

    // Poll LFO values for subtle "breathing" and "warmth shimmer"
    // (This avoids extra routing complexity and keeps CPU stable.)
    const breathDepth = lerp(0.02, 0.20, hum*(0.3+0.7*sheltered));
    lfoBreath.frequency.setValueAtTime(lerp(0.06, 0.22, modRate/5.0), t);
    lfoBreathGain.gain.setValueAtTime(breathDepth, t);

    lfoWarm.frequency.setValueAtTime(lerp(0.015, 0.06, heat), t);
    lfoWarmGain.gain.setValueAtTime(lerp(0.0, 0.18, heat*(0.4+0.6*hum)), t);

    ui.depthRead.textContent = depth.toFixed(2);

    // Master dB readout
    ui.masterDb.textContent = `${gainToDb(state.master).toFixed(1)} dB`;
  }

  // ---------- Spore Events ----------
  function spawnSporeBurst(){
    if(!ctx) return;
    const t = now(ctx);
    const depth = state.depth;
    const wind = state.wind;
    const heat = state.heat;
    const hum  = state.hum;

    // In the chapter, spores must rise above the boundary layer into turbulence.
    // We model that as a short rising tone + noisy "opening capsule" tick, panned wide.
    const riseDur = lerp(0.18, 0.60, clamp(0.25 + 0.55*wind));
    const base = lerp(240, 520, heat);
    const top  = base * lerp(2.2, 5.0, clamp(0.25 + 0.75*(1-depth) + 0.35*wind));
    const pan = (Math.random()*2-1) * lerp(0.25, 0.95, state.pan);

    const oC = ctx.createOscillator();
    oC.type = "sine";

    const oM = ctx.createOscillator();
    oM.type = "sine";
    const oMG = ctx.createGain();

    const amp = ctx.createGain();
    amp.gain.value = 0.0;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass"; bp.Q.value = lerp(4, 14, 0.5 + 0.5*hum);
    bp.frequency.value = lerp(900, 2400, heat);

    const p = ctx.createStereoPanner();
    p.pan.value = pan;

    // small noise tick (capsule opening)
    const tick = ctx.createBufferSource();
    tick.buffer = makeNoiseBuffer(ctx, 0.15);
    const tickHP = ctx.createBiquadFilter();
    tickHP.type = "highpass"; tickHP.frequency.value = 2200;
    const tickA = ctx.createGain();
    tickA.gain.value = 0.0;

    // FM
    oM.connect(oMG);
    oMG.connect(oC.frequency);

    oC.connect(bp);
    bp.connect(amp);
    amp.connect(p);
    p.connect(sporeBus);

    tick.connect(tickHP);
    tickHP.connect(tickA);
    tickA.connect(p); // share panner

    // Schedule
    oC.frequency.setValueAtTime(base, t);
    oC.frequency.exponentialRampToValueAtTime(top, t + riseDur);

    oM.frequency.setValueAtTime(base*lerp(3, 8, 0.4+0.6*wind), t);
    oMG.gain.setValueAtTime(lerp(30, 180, 0.4 + 0.6*wind), t);

    // envelope
    const peak = lerp(0.05, 0.18, 0.5 + 0.5*wind) * (1 - 0.35*state.reverb);
    amp.gain.setValueAtTime(0.0, t);
    amp.gain.linearRampToValueAtTime(peak, t + 0.02);
    amp.gain.exponentialRampToValueAtTime(0.0008, t + riseDur + 0.12);

    // tick
    tickA.gain.setValueAtTime(0.0, t);
    tickA.gain.linearRampToValueAtTime(lerp(0.01, 0.05, wind), t + 0.006);
    tickA.gain.exponentialRampToValueAtTime(0.0008, t + 0.06);

    oC.start(t);
    oM.start(t);
    tick.start(t);

    const stopT = t + riseDur + 0.25;
    oC.stop(stopT);
    oM.stop(stopT);
    tick.stop(t + 0.10);

    spores.push({oC,oM,tick, stopT});
  }

  function cleanupSpores(){
    if(!ctx) return;
    const t = now(ctx);
    for(let i=spores.length-1; i>=0; i--){
      if(spores[i].stopT < t - 0.05){
        try{ spores[i].oC.disconnect(); }catch(e){}
        try{ spores[i].oM.disconnect(); }catch(e){}
        try{ spores[i].tick.disconnect(); }catch(e){}
        spores.splice(i,1);
      }
    }
  }

  // ---------- Render + Modulation Loop ----------
  const viz = {
    ctx: ui.canvas.getContext("2d"),
    w: ui.canvas.width,
    h: ui.canvas.height,
    buf: new Uint8Array(2048),
    timeBuf: new Uint8Array(2048),
    lastSporeFlash: 0
  };

  function draw(){
    const g = viz.ctx;
    const W = ui.canvas.width, H = ui.canvas.height;

    // Resize for device pixel ratio
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const cssW = ui.canvas.clientWidth;
    const cssH = ui.canvas.clientHeight;
    const needW = Math.floor(cssW * dpr);
    const needH = Math.floor(cssH * dpr);
    if(ui.canvas.width !== needW || ui.canvas.height !== needH){
      ui.canvas.width = needW; ui.canvas.height = needH;
    }

    g.clearRect(0,0,ui.canvas.width,ui.canvas.height);

    // Background
    g.fillStyle = "rgba(6,10,16,0.85)";
    g.fillRect(0,0,ui.canvas.width,ui.canvas.height);

    // Boundary layer band
    const depth = state.depth;
    const bandH = lerp(0.18, 0.62, depth) * ui.canvas.height;
    const y0 = ui.canvas.height - bandH;

    // Subtle gradient for boundary layer
    const grad = g.createLinearGradient(0,y0,0,ui.canvas.height);
    grad.addColorStop(0, "rgba(125,211,252,0.06)");
    grad.addColorStop(0.5, "rgba(52,211,153,0.06)");
    grad.addColorStop(1, "rgba(251,191,36,0.07)");
    g.fillStyle = grad;
    g.fillRect(0, y0, ui.canvas.width, bandH);

    // boundary line
    g.strokeStyle = "rgba(203,213,225,0.12)";
    g.lineWidth = 2;
    g.beginPath();
    g.moveTo(0, y0);
    g.lineTo(ui.canvas.width, y0);
    g.stroke();

    // Labels
    g.fillStyle = "rgba(217,227,240,0.75)";
    g.font = `${Math.floor(12*(window.devicePixelRatio||1))}px system-ui`;
    g.fillText("turbulent air", 14, Math.max(18, y0-10));
    g.fillText("boundary layer (still air)", 14, ui.canvas.height - 14);

    // Draw spectrum if running
    if(ctx && state.running){
      analyser.getByteFrequencyData(viz.buf);
      analyser.getByteTimeDomainData(viz.timeBuf);
    } else {
      viz.buf.fill(0);
      viz.timeBuf.fill(128);
    }

    // Spectrum bars
    const n = 170;
    const step = Math.floor(viz.buf.length / n);
    const barW = ui.canvas.width / n;

    for(let i=0;i<n;i++){
      const v = viz.buf[i*step] / 255;
      const x = i * barW;
      const h = v * (ui.canvas.height * 0.55);
      const yy = ui.canvas.height - h;

      // Color split: low (CO2) purple, mid (vowels) green, high (wind) blue
      let r=120,gc=140,b=200,a=0.10 + 0.40*v;
      if(i < n*0.18){ r=167; gc=139; b=250; }
      else if(i < n*0.55){ r=52; gc=211; b=153; }
      else { r=125; gc=211; b=252; }

      g.fillStyle = `rgba(${r},${gc},${b},${a})`;
      g.fillRect(x, yy, Math.max(1, barW-1), h);
    }

    // Time-domain "surface contour"
    g.strokeStyle = "rgba(217,227,240,0.20)";
    g.lineWidth = 2;
    g.beginPath();
    const td = viz.timeBuf;
    for(let i=0;i<td.length;i+=6){
      const x = (i/(td.length-1)) * ui.canvas.width;
      const v = (td[i]-128)/128;
      const y = y0 + (bandH*0.50) + v*(bandH*0.32);
      if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
    }
    g.stroke();

    // Parameter traces (wind/heat/hum/co2)
    function drawTrace(value, color, yBase){
      g.strokeStyle = color;
      g.lineWidth = 2;
      g.beginPath();
      const amp = ui.canvas.height * 0.08;
      for(let i=0;i<=100;i++){
        const x = (i/100)*ui.canvas.width;
        const wob = Math.sin((i/100)*Math.PI*2 + (performance.now()*0.001)) * 0.35;
        const y = yBase - (value*amp) + wob*amp*0.2;
        if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
      }
      g.stroke();
    }
    drawTrace(state.wind, "rgba(125,211,252,0.55)", y0*0.50);
    drawTrace(state.heat, "rgba(251,191,36,0.55)", y0*0.72);
    drawTrace(state.hum,  "rgba(52,211,153,0.55)", y0*0.90);
    drawTrace(state.co2,  "rgba(167,139,250,0.60)", y0*0.62);

    // Spore flash
    const flash = Math.max(0, viz.lastSporeFlash - performance.now());
    if(flash > 0){
      const a = clamp(flash/220);
      g.fillStyle = `rgba(251,113,133,${0.10 + 0.20*a})`;
      g.fillRect(0,0,ui.canvas.width,ui.canvas.height);
      // rising streak
      g.strokeStyle = `rgba(251,113,133,${0.40*a})`;
      g.lineWidth = 3;
      g.beginPath();
      const x = ui.canvas.width * (0.25 + 0.5*Math.sin(performance.now()*0.004));
      g.moveTo(x, ui.canvas.height);
      g.lineTo(x + 40*Math.sin(performance.now()*0.01), 0);
      g.stroke();
    }

    raf = requestAnimationFrame(draw);
  }

  function tickModulation(){
    if(!ctx || !state.running) return;

    const t = now(ctx);
    const depth = state.depth;
    const wind = state.wind;
    const heat = state.heat;
    const hum = state.hum;
    const co2 = state.co2;

    // Read LFOs by sampling their phase approximately (use currentTime)
    const breath = Math.sin(2*Math.PI*(0.13*t));
    const warm = Math.sin(2*Math.PI*(0.035*t));

    // Subtle organic movement:
    // - voice pitch drifts more in turbulence
    const sheltered = depth;
    const turbulent = clamp(wind * (1 - 0.65*sheltered));
    const pitchWob = lerp(0.2, 6.0, turbulent) * breath * 0.18;

    // - amplitude "moisture breathing"
    const ampBreath = (0.5 + 0.5*breath) * lerp(0.0, 0.12, hum*(0.2+0.8*sheltered));

    // - warmth shimmer opens highs gently
    const highShimmer = warm * lerp(0.0, 1.2, heat*(0.3+0.7*hum));

    // apply small offsets (do not fight main mapping; keep tiny)
    try{
      vCarrier.detune.setValueAtTime(pitchWob, t);
      const baseAmp = vAmp.gain.value;
      // avoid runaway by referencing mapped target in applyAllParams; so only micro-adjust via setTarget
      setParam(vAmp.gain, clamp(baseAmp + ampBreath*0.015, 0, 0.5), t, 0.05);

      // EQ shimmer
      const baseHigh = lerp(-1.0, 6.0, heat*(0.4+0.6*sheltered));
      setParam(eqHigh.gain, baseHigh + highShimmer, t, 0.10);

      // CO2 slight pulsing (microbial respiration)
      const co2Pulse = (0.5 + 0.5*Math.sin(2*Math.PI*(0.06*t + 0.01*Math.sin(2*Math.PI*0.013*t))));
      setParam(cAmp.gain, (0.01 + 0.14 * clamp(co2*(0.35+0.65*sheltered))) * lerp(0.92, 1.05, co2Pulse), t, 0.12);
    }catch(e){}

    // Spore scheduling:
    // More spores when spore control is high AND when wind is enough to "catch" above boundary.
    const chance = state.spore * (0.25 + 0.75*wind) * (0.35 + 0.65*(1-depth));
    const interval = lerp(6.0, 0.8, chance); // seconds
    // Use a simple timer based on performance.now
    if(!tickModulation._next) tickModulation._next = performance.now() + interval*1000;
    if(performance.now() >= tickModulation._next){
      spawnSporeBurst();
      viz.lastSporeFlash = performance.now() + 220;
      // next time with jitter
      const jitter = lerp(0.6, 0.22, chance);
      tickModulation._next = performance.now() + (interval * (0.75 + Math.random()*jitter))*1000;
    }

    cleanupSpores();
    // periodically re-apply mapped params (keeps stable under micro-mod)
    if(!tickModulation._reapply) tickModulation._reapply = performance.now();
    if(performance.now() - tickModulation._reapply > 180){
      applyAllParams(false);
      tickModulation._reapply = performance.now();
    }

    // CPU-safe: avoid very long IRs; already fixed length. If overloaded, reduce analyser cost.
    // (Not measuring load; just a toggle in UI.)
    setTimeout(tickModulation, state.cpuSafe ? 50 : 25);
  }

  // ---------- Scenes ----------
  function setScene(key){
    const s = SCENES[key];
    if(!s) return;
    state.scene = key;
    ui.sceneName.textContent = s.name;

    // update sliders (and state)
    const map = {
      depth:s.depth, wind:s.wind, heat:s.heat, hum:s.hum, co2:s.co2, spore:s.spore, vowel:s.vowel, pan:s.pan, reverb:s.reverb
    };
    for(const k in map){
      state[k] = map[k];
      ui[k].value = map[k];
    }
    // refresh readouts
    refreshUIReadouts();
    if(ctx) applyAllParams(true);

    sceneButtons.forEach(b => b.classList.toggle("sel", b.dataset.scene === key));
  }

  function refreshUIReadouts(){
    ui.depthVal.textContent = fmt(state.depth);
    ui.windVal.textContent  = fmt(state.wind);
    ui.heatVal.textContent  = fmt(state.heat);
    ui.humVal.textContent   = fmt(state.hum);
    ui.co2Val.textContent   = fmt(state.co2);
    ui.sporeVal.textContent = fmt(state.spore);
    ui.vowelVal.textContent = fmt(state.vowel);
    ui.panVal.textContent   = fmt(state.pan);
    ui.revVal.textContent   = fmt(state.reverb);
    ui.masterVal.textContent= fmt(state.master);
    ui.depthRead.textContent = state.depth.toFixed(2);
    ui.masterDb.textContent = `${gainToDb(state.master).toFixed(1)} dB`;
  }

  // ---------- UI wiring ----------
  bindRange(ui.depth, ui.depthVal, v => { state.depth=v; ui.depthRead.textContent = v.toFixed(2); if(ctx) applyAllParams(false); });
  bindRange(ui.wind, ui.windVal, v => { state.wind=v; if(ctx) applyAllParams(false); });
  bindRange(ui.heat, ui.heatVal, v => { state.heat=v; if(ctx) applyAllParams(false); });
  bindRange(ui.hum, ui.humVal, v => { state.hum=v; if(ctx) applyAllParams(false); });
  bindRange(ui.co2, ui.co2Val, v => { state.co2=v; if(ctx) applyAllParams(false); });
  bindRange(ui.spore, ui.sporeVal, v => { state.spore=v; if(ctx) applyAllParams(false); });
  bindRange(ui.vowel, ui.vowelVal, v => { state.vowel=v; if(ctx) applyAllParams(false); });
  bindRange(ui.pan, ui.panVal, v => { state.pan=v; if(ctx) applyAllParams(false); });
  bindRange(ui.reverb, ui.revVal, v => { state.reverb=v; if(ctx) applyAllParams(false); });
  bindRange(ui.master, ui.masterVal, v => {
    state.master=v;
    ui.masterDb.textContent = `${gainToDb(v).toFixed(1)} dB`;
    if(ctx) applyAllParams(false);
  });

  sceneButtons.forEach(btn => btn.addEventListener("click", () => setScene(btn.dataset.scene)));

  ui.startBtn.addEventListener("click", async () => {
    if(ctx) return;
    ui.status.textContent = "starting…";
    ui.startBtn.disabled = true;
    try{
      buildAudio();
      await ctx.resume();
      ui.status.textContent = "running";
      ui.stopBtn.disabled = false;

      // Start loops
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(draw);
      tickModulation._next = 0;
      tickModulation._reapply = 0;
      tickModulation();

    }catch(e){
      console.error(e);
      ui.status.textContent = "error";
      ui.startBtn.disabled = false;
    }
  });

  ui.stopBtn.addEventListener("click", () => {
    ui.stopBtn.disabled = true;
    ui.status.textContent = "stopping…";
    stopAudio();
    ui.status.textContent = "stopped";
    ui.startBtn.disabled = false;
  });

  // Click canvas toggles CPU-safe mode (handy on mobile)
  ui.canvas.addEventListener("click", () => {
    state.cpuSafe = !state.cpuSafe;
    ui.safe.textContent = state.cpuSafe ? "on" : "off";
  });

  window.addEventListener("keydown", (e) => {
    if(e.code === "Space"){
      e.preventDefault();
      if(!ctx) ui.startBtn.click(); else ui.stopBtn.click();
    }
    if(e.key.toLowerCase() === "s"){
      spawnSporeBurst();
      viz.lastSporeFlash = performance.now() + 220;
    }
  });

  // initial scene
  setScene("forest");
  refreshUIReadouts();
  ui.safe.textContent = state.cpuSafe ? "on" : "off";
  ui.status.textContent = "stopped";
  draw(); // idle viz
})();
</script>
</body>
</html>

